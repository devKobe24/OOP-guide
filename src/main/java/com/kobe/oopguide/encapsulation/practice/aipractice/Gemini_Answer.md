# Java Spring Boot 시니어 개발자로서의 GEMINI 답변.
* 예시 코드를 참고하여 직접 고민하고 코드를 짜보는 것은 실력 향상에 가장 좋은 방법입니다.

## GEMINI의 코드 리뷰.

* 전반적으로 **캡슐화의 기본 개념을 매우 잘 이해하고 적용**함.
  * `level` 데이터를 `private`으로 숨긴것.
  * `championLevelUp()`이라는 공개된 메서드를 통해 레벨을 올리는 로직을 `Champion` 객체(Object) 스스로가 책임지도록한 것.
    * 이것들이 바로 캡슐화(Encapsulation)의 핵심입니다.
  * `champion.championLevelUp()`이라는 메시지만 전달하는 것도 "Tell, Don't Ask" 원칙을 잘 따른 훌륭한 코드입니다.

---

## ✅ Good Points(잘된 점)
* **데이터 은닉:** `level` 필드를 `private`으로 선언하여 외부에서 직접 접근하고 수정하는 것을 완벽하게 차단했습니다.
* **행위 위임:** `SummonerService`가 챔피언의 레벨을 직접 계산하거나 변경하지 않고, `champion.championLevelUp()` 메서드를 호출하여 챔피언 객체에게 그 행위를 위임한 점이 훌륭합니다.
* **상태와 행동의 일치:** 챔피언의 레벨(`level`이라는 상태)과 레벨을 올리는 로직(`championLevelUp()`이라는 행동)이 `Champion` 이라는 하나의 클래스 안에 함께 존재하여 객체의 응집도(Cohesion)가 높습니다.

## ❌ Improvement Points(개선할 점)
**1. 불필요한 인터페이스와 SRP(단일 책임 원칙) 위반**
* 현재 `Champion` 클래스는 `SummerSkillAndLevelUpInterface`라는 인터페이스를 구현하고 있습니다.
  * 하지만 이 인터페이스는 "레벨 업"과 "스킬 선택"이라는 **서로 다른 두 가지 택임을 하나로 묶고 있습니다.** 
  * 이는 인터페이스 분리 원칙(ISP, Interface Segregation Principle)에 어긋날 수 있습니다.
  * 현재로서는 `Champion` 외에 다른 구현체가 없으므로 다소 불필요한 추상화로 보입니다.
* 또한, `selectSkillUnderLevelSix`와 `selectSkillOverLevelSix` 메서드는 "스킬을 선택한다"는 **하나의 책임을 레벨에 따라 분리**하여 `Champion` 클래스를 불필요하게 복잡하게 만들고 있습니다.

**↳ 🛠️ 리팩토링 방향:**
* **인터페이스 제거** ➞ `Champion` 클래스가 스스로의 역할에만 집중하도록 합니다.
* **단일 책임(SRP)을 갖도록 만들기** ➞ `selectSkill` 메서드를 하나로 통합하여, 메서드 내부에서 레벨을 확인하고 그에 맞는 로직을 처리하도록 하여 **단일 책임을 갖도록** 만듭니다.

**2. 반환 타입의 부재와 로직의 불완전함**
* `selectSkill...` 메서드들은 스킬 선택 결과를 `System.out.println`으로 출력만 할 뿐, 실제 스킬이 선택되었는지, 어떤 스킬이 선택되었는지에 대한 **결과를 반환하지 않습니다.**
  * `selectSkillOverLevelSix`의 경우, `selectSkill = "Q"`와 같이 파라미터 변수에 값을 재할당하지만, 이 값은 메서드가 끝나면 사라지므로 아무런 의미가 없습니다.

**↳ 🛠️ 리팩토링 방향:**
* **메서드의 실행 결과를 명확한 반환 값(return value)으로 알려주기** ➞ 예를 들어, 스킬 선택 성공 여부를 `boolean`으로 반환하거나, 선택된 스킬 자체를 반환할 수 있습니다.
* **견고한 설계하기** ➞ 유효하지 않은 행동(예: 6레벨 미만에 R 스킬 선택)에 대해서는 단순히 `println`으로 메시지를 출혁하기보다, **예외(Exception)** 를 발생시켜 호출한 쪽(서비스)에서 이 문제를 명확히 인지하고 처리하도록 하는 것이 더 견고한 설계입니다.

**3. 도메인 객체와 서비스의 역할**
* 현재 `SummonerService`가 단순히 `Champion`의 메서드를 그대로 호출하는 역할만 하고 있습니다.
  * (이것이 잘못된 것은 아님.) 
  * 하지만, 서비스 계층은 보통 **더 의미 있는 비즈니스 로직**을 담거나, 여러 도메인 객체 간의 **상호작용을 조율(Orchestration)** 하는 역할을 합니다.

**↳ 🛠️ 리팩토링 방향:**
* `Champion`이 스킬 선택 로직을 더 완벽하게 책임지도록 만들고, `SummonerService`는 `Champion` 객체를 사용하는 더 큰 그림의 역할을 수행하도록 합니다.