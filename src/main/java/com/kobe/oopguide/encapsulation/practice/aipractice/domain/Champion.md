# 2. `Champion` Domain (리팩토링)
* 훨씬 더 간결하고 명확한 책임을 갖는 `Champion` 클래스입니다.

## Q. 🤔 Champion Class는 SRP(단일 책임 원칙)을 어긴게 아닐까?
### A. 아닙니다.

먼저, 왜 SRP를 어겼다고 생각했는지 알아보겠습니다.

* 🤔 Champion 클래스가 SRP(Single Responsibility Principle, 단일 책임 원칙)을 어겼다고 생각한 이유가 무엇이야?
  * 그 이유는 두 가지로 나누어 말할 수 있어.
    * 첫번째, 🙋‍♂️ Champion 클래스는 `levelUp`메서드를 통해 '레벨업'이라는 행위와 그 규칙을 스스로 **'책임'** 지고 있기 때문이야.
    * 그리고 마지막 두번째, `selectSkill` 메서드를 통해 '스킬 선택'이라는 행위와 모든 규칙(레벨 저한 등)을 **'책임'** 지고 있기 때문이야.
      * 그래서 결국, 나는 Champion 클래스가 두 가지의 책임을 지고 있다고 생각했어. 

> '책임(Responsibility)'의 의미
> * **책임(Responsibility)** 은 SRP에서 정의하는 개념으로, ➞ **"클래스가 변경될 이유(변경 사유, 변화의 축)"** 를 말합니다.
> * 즉, 어떤 클래스가 어떤 기능이나 규칙을 **끝까지 맡아서 관리하고 유지할 것인지**에 대한 "책임 범위"입니다.
> * 예: Champion 클래스가 "레벨업 규칙"도 바뀔 때마다 수정해야 하고, "스킬 선택 규칙"이 바뀔 때마다 수정해야 한다면 ➞ 두 가지 책임을 동시에 가진 것 입니다.

이제, 시니어 개발자의 관점에서 왜 현재 `Champion` 클래스가 SRP를 위반한 것이 아니라, 오히려 **객체지향적으로 매우 잘 설계된 것**인지 명확하게 설명해보겠습니다.

이것을 이해하기 위해서는 SRP(Single Responsibility Principle, 단일 책임 원칙)의 핵심 정의를 다시 살펴봐야 합니다.
* **"클래스를 변경해야할 이유는 단 하나뿐이어야 한다"**
  * 여기서 "변경의 이유"는 보통 하나의 **"역할" 또는 "개념"** 과 연결됩니다.

**`Champion` 클래스 단 하나의 책임.**
* Champion` 클래스 단 하나의 책임. ➞ **"게임 내 '챔피언'이라는 존재의 상태와 행위를 관리하는 것"** 입니다.
  * **상태(Data) :** `level`, `learnedSkills`
  * **행위(Behavior) :** `levelUp()`, `selectSkill()`

* **`levelUp()` 메서드를 변경해야 하는 이유** ➞ **"게임의 레벨업 정책이 바뀔 때"**
* **`selectSkill()` 메서드를 변경해야 하는 이유** ➞ **"게임의 스킬 습득 정책이 바뀔 때"**
 * 이 두 가지 변경 이유는 모두 **'챔피언의 성장 규칙'** 이라는 더 큰 개념 안에 포함됩니다.
   * 즉, `levelUp()`과 `selectSkill()`은 **'챔피언'이라는 단일 책임을 구성하는 매우 응집도 높은(highly cohesive) 행위들**입니다.
     * 챔치언의 레벨과 스킬은 서로에게 강하게 영향을 미치므로 (레벨이 올라야 스킬을 배울 수 있음), 이 로직들이 하나의 클래스 안에 묶여있는 것은 매우 자연스럽고 올바른 설계입니다.

### ✌️ 최종 정리
* `Champion` 클래스에 `levelUp()`과 `selectSkill()`이 함께 있는 것은 두 개의 책임을 가진 것이 아니라, **"챔피언" 이라는 단 하나의 추상적인 책임을 완성하기 위한 여러 개의 구체적인 책무(duties)** 를 가진 것입니다,
* 오히려 로직들을 분리했다면, 챔피언의 상태를 외부 서비스들이 직접 제어하게 되어 캡슐화가 깨지고 객체가 단순히 데이터 덩어리로 전락하는 **빈약한 도메인 모델(Anemic Domain Model)** 이 되었을 것입니다.

**따라서 현재 `Champion` 클래스는 캡슐화와 SRP를 매우 잘 지킨 훌륭한 객체지향 설계의 예시라고 할 수 있습니다.**