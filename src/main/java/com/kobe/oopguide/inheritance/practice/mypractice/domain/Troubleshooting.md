### ❌ 문제점 1: 잘못된 상속 설계(가장 중요한 문제)
* 상속은 **"A는 B의 한 종류이다(IS-A relationship)"** 관계가 성립할 때 사용해야 합니다.
  * 예를 들어, "강아지는 동물의 한 종류이다"는 자연스럽습니다.

**이전 코드의 `BaseEntity`에는 `costPrice`, `regularPrice`, `barcodeNumber` 필드가 포함되어 있었습니다.**
* "상품(`Product`)은 가격과 바코드를 가진 존재의 한 종류이다" ➞ 자연스럽습니다.
* "재고(`Stock`)는 가격과 바코드를 가진 존재의 한 종류이다." ➞ **어색합니다.**

### 🤔 왜 어색할까?
* 현실 세계에서 '재고'는 그 자체로 독립적인 가격이나 바코드를 갖지 않습니다.
  * 재고는 **'어떤 상품'(`Product`)** 에 속해 있으며, 그 상품의 가격과 바코드를 따라갈 뿐입니다.
* 이전 설계대로라면, `Product` 테이블과 `Stock` 테이블 모두에 `cost_price`, `regular_price`, `barcode_number` 컬럼이 각각 생성됩니다.
  * 이는 심각한 문제를 야기합니다.
    * **데이터 중복 :** 똑같은 정보가 여러 테이블에 중복 저장되어 데이터베이스 공간을 낭비.
    * **데이터 불일치 :** 만약 상품의 가격을 변경해야 할 때, `Product` 테이블뿐만 아니라 그 상품에 속한 모든 `Stock` 테이블의 레코드를 전부 찾아가며 가격을 바꿔줘야 합니다. 하나라도 놓치면 데이터가 틀어지는 끔직한 문제가 발생합니다.

### ❌ 문제점 2: 누락된 JPA 어노테이션
* `Product`와 `Stock` 클래스에 `@Entity` 어노테이션 빠져있습니다.
  * 이 어노테이션이 없으면 JPA(하이버네이트)는 이 클래스들을 데이터베이스 테이블과 매핑해야 할 엔티티로 인식하지 못해 오류가 발생합니다.

### ✅ 올바른 리팩토링 방향: 상속과 구성(Composition)의 올바른 사용
이 문제를 해결하기 위해서는 **상속(Inheritance)** 과 **구성(Composition, 연관관계 매핑)** 의 역할을 명확하게 분리해야 합니다.

1. **`BaseEntity` (상속용) :** 모든 엔티티가 공통으로 가져야 할 **메타데이터(생성일시, 수정일시 등)만 남겨둡니다.**
2. **`Product` (핵심 도메인) :** `BaseEntity`를 상속받고, **상품만이 가지는 고유한 속성**(가격, 바코드 등)을 직접 선언합니다.
3. **`Stock` (종속 도메인) :** `BaseEntity`를 상속받고, `Product`와의 **연관관계(`@ManyToOne`)** 를 맺어 "나는 어떤 상품에 속한 재고"인지를 표현합니다.(이를 '구성'이라고 합니다.)
